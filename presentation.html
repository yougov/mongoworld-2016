<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>From the Polls to the Trolls: Seeing What The World Thinks at YouGov</title>

		<meta name="description" content="YouGov showcases their global cluster at MongoWorld 2016">
		<meta name="author" content="YouGov, Plc.">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="white-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="https://yougov.github.io/reveal.js/css/reveal.css">
		<link rel="stylesheet" href="https://yougov.github.io/reveal.js/css/theme/white.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="https://yougov.github.io/reveal.js/lib/css/zenburn.css">

		<link rel="stylesheet" href="theme/yougov.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			var path = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			link.href = 'https://yougov.github.io/reveal.js/' + path;
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>

	</head>

	<body>

		<div class="reveal">

			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">

				<section>
					<h1>From the Polls to the Trolls</h1>
					<h3>Seeing what the world thinks at <a href="https://today.yougov.com/">YouGov</a></h3>
				</section>

				<section style="background: rgba(255,255,255,0.5)">
					<ul>
						<li style="padding: 1em;">YouGov conducts highly dynamic surveys that rely on MongoDB's rich support for semi-structured data.</li>

						<li style="padding: 1em;">YouGov uses tag-aware sharding to provide MongoDB-as-a-Service (MongoDBaaS) for a global operation.</li>

						<li style="padding: 1em;">MongoDB is a joy to use and an effective multipurpose persistence store for large-scale applications.</li>
					</ul>
				</section>

				<section>
					<section>
						<h2>About Us</h2>
						<aside class="notes">
						Before we go into the talk, allow
						me to briefly tell you about YouGov.
						</aside>
					</section>

					<section>
						<h2>About YouGov</h2>
						<ul>
							<li>community</li>
							<li>opinions &amp; habits</li>
							<li>smart analysis</li>
							<li>insights and prediction</li>
							<li><a target="_blank" href="https://today.yougov.com/?stay">today.yougov.com</a></li>
						</ul>
						<aside class="notes">YouGov maintains a continuous conversation with the community, working with members of our panel to better understand their opinions and habits. Then we apply smart analysis to those isolated data points to model an accurate picture of what the world thinks, and then share this insight and predictive capability to corporations, governments, and other organizations to help them make meaningful decisions. Our US home page tells this story well, so I'd like to briefly share that with you.</aside>
					</section>

					<section>
						<img data-src="press clippings 5.png">
						<aside class="notes">Many top-tier news agencies call on YouGov to get accurate data on consumer sentiment, policital leanings, and any sort of opinion you can imagine.</aside>
					</section>

					<section>
						<h2>About YouGov Dev</h2>
						<ul>
							<li>38 developers in 9 countries</li>
							<li>primarily leverage Python and open-source</li>
							<li>high interactivity and integration</li>
							<li>streamlined deployment</li>
						</ul>
						<aside class="notes">All of our developers work in a virtual environment and many including myself have no home office. We use Python as a first-class production language. We used IRC and now Slack for high interactivity and integrated experience. Hypermedia enables a cohesive experience despite geographic distances. We use Velociraptor for high-agility near-continuous deployment and developers deploy the first day. The environment supports hundreds of applications on dozens of virtual machines organized in squads.</aside>
					</section>

					<section data-background="https://www.dropbox.com/s/rnq3st8275obhur/WeyTravel98.jpg?dl=1" style="background: rgba(255,255,255,0.5)">
						<h2>About Jason</h2>
						<ul>
							<li>passion for Python</li>
							<li>studied web data (semi-structured)</li>
							<li>motivated to unfetter data</li>
						</ul>
						<aside class="notes">I struggled with the disparity between structured databases and my application's inherent models. I found myself writing my own ORMs before experimenting with SQLObject and later SQLAlchemy. But even those models fell short of modeling semi-structured data. I wanted a solution that was as flexible as XML, and even evaluated XML databases. I discovered MongoDB shortly before joining YouGov in 2010, where YouGov had just migrated the flagship survey system to MongoDB, so I was eager to develop against it.</aside>
					</section>

				</section>

				<section>
					<section>
						<h1>Two Challenges</h1>
						<aside class="notes">
						YouGov faces many challenges, but today I will focus on two that are particularly salient to this audience.
						</aside>
					</section>

					<section>
						<h2>Challenge: Survey Collection</h2>
						<ul>
							<li>highly dynamic surveys</li>
							<li>programmed by users</li>
							<li>semi-structured data</li>
							<li>high throughput</li>
							<li><em>increasing</em> throughput</li>
						</ul>
						<aside class="notes">The first challenge is our traditional core offering - survey data collection. Questionnaires are programmed by users and each contains a unique arrangement of variable names and types, but there are some attributes of the collection that are intrinsic to the system. The structured and unstructured portions combine to form a semi-structured record at the heart of the prcoess. The servers handle a fairly high throughput, with daily peak submission rate approaches 4K/minute and this data throughput is increasing, where in 2011, we processed 5GB/mo, that same system is now seeing 90GB/mo (as of Winter 2015).
						</aside>
					</section>

					<section>
						<h2>Challenge: Global Operation</h2>
						<img data-src="YouGov_panel_map.png">
						<aside class="notes">
						<ul>
							<li>YouGov operates in 37 countries on 5 continents</li>
							<li>local responsiveness crucial</li>
							<li>avoid specialized datastore</li>
							<li>jurisdictional constraints</li>
						</ul>
						</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>The Plan</h2>
						<aside class="notes">
						Our dev team set out to tackle each of
						these two challenges within MongoDB.
						</aside>
					</section>

					<section>
						<h2>Flexible Data Model</h2>
						<ul>
							<li>store survey responses as document</li>
							<li>(automatic) schema migration</li>
						</ul>
						<aside class="notes">YouGov solves the survey data storage challenge by implementing a flexible data model. Originally, responses were stored as a blob of pickled Python. In late 2009, we selected MongoDB to replace that somewhat brittle technique, storing much of the unstructured data in fields of the document like 'answers' and 'timings', but storing strucural aspects in other fields like 'questionnaire_name' or 'ident' (creating an implied schema). As with any mature system, we anticipate the expectations of the application will change over time. We need a mechanism to manage the evolution of the schema as we develop the application, and for this, we built a technique to automate support for the migration.</aside>
					</section>

					<section>
						<h2>Global Sharded Cluster</h2>
						<ul>
							<li>2 datacenters separated by 5,400 miles</li>
							<li>partitions survey data via tag-aware sharding</li>
							<li>provides Database-as-a-Service (DBaaS)</li>
						</ul>
						<aside class="notes">To address the challenge of serving many applications in a unified global environment, we first recognized that the foundation of our application is the database, and so it would need to operate unified yet globally-distributed fashion. Thankfully, MongoDB also was innovating around these needs and was implementing replica sets and sharding and then tag aware sharding. We set out to leverage  these features to create a single sharded cluster spanning two data centers, but representing a single global set of databases as a part of the infrastructure available to any and all applications.</aside>
					</section>
				</section>

				<section>
					<h2>Diving In</h2>
					<aside class="notes">
					Here, we'll go into depth on our two key observations
					</aside>
				</section>

				<section>

					<section>
						<h2>Migration Manager</h2>
						<ul>
							<li>schema version</li>
							<li>incrementing integer</li>
							<li>migrates on load</li>
							<li>untouched on save</li>
						</ul>

						<aside class="notes">The lean and agile methodology we employ incentivizes our developers to identify meaningful, incremental changes to the system, roll that into production quickly, and if issues arise, roll back quickly. Sometimes these changes necessitate changes to the structure (or schema) of the documents, and it's expensive to stop operations to perform an offline migration. Instead, to address the changes to the schema as the application evolves, we developed a Migration Manager, a sort of adapter or translator that we install between the database driver and the application models. Similar to static migration tools, we assign a version for each schema change with an incrementing integer, and then provide code to migrate a given document from one schema version to the next and back. The Migration Manager then is initialized with a target schema version (the version that the application is designed against), and it migrates each document on load. On save, the application saves naturally in its default version. Allow me to illustrate with a crude drawing.
						</aside>

					</section>

					<section data-background="Manager%20Diagram.png">
					</section>

					<section>
						<h2>Implementation (1)</h2>
						<pre><code>class Manager(object):
    """
    Tag the functions with a target version and keep a registry of which
    functions were tagged with which revision.
    """
    _upgrade_funcs = set()

    def __init__(self, region, target_version):
        self.region = region
        self.target_version = target_version
        self.session = requests.session()

    @classmethod
    def register(cls, func):
        """
        Decorate a migration function with this method
        to make it available for migrating cases.
        """
        cls._add_version_info(func)
        cls._upgrade_funcs.add(func)
        return func</code></pre>
					</section>

					<section>
						<h2>Implementation (2)</h2>
						<pre><code>class Manager(object):
    def migrate_case(self, case):
        """
        Migrate the case from its current version to the target version
        and return it.
        """
        orig_ver = case.get('session_version', 0)
        funcs = self._get_migrate_funcs(orig_ver, self.target_version)
        for func in funcs:
            func(self, case)
            case['session_version'] = func.target
        return case

    @classmethod
    def _get_migrate_funcs(cls, orig_version, target_version):
        """
        >>> funcs = list(Manager._get_migrate_funcs(1, 3))
        >>> len(funcs)
        2
        >>> funcs == [v1_to_2, v2_to_3]
        True
        >>> funcs = list(Manager._get_migrate_funcs(7, 6))
        >>> len(funcs)
        1
        >>> funcs == [v7_to_6]
        True
        """
        direction = 1 if target_version > orig_version else -1
        versions = range(orig_version, target_version + direction, direction)
        transitions = recipes.pairwise(versions)
        return itertools.starmap(cls._get_func, transitions)</code></pre>
					</section>

					<section>
						<h2>Implementation (3)</h2>
						<pre><code>@Manager.register
def v6_to_7(manager, case):
    """
    V7 adds the survey_id and user_id fields
    """
    ident = CaseIdent(case.get('ident', ''))
    case.setdefault('user_id', ident.user_id)
    case.setdefault('survey_id', ident.survey_id)

@Manager.register
def v7_to_6(manager, case):
    ident = CaseIdent.from_parts(
        case.pop('user_id', None),
        case.pop('survey_id', None),
    )
    case['ident'] = str(ident)</code></pre>
					</section>


					<section>
						<h2>Caution: Field Rename</h2>
						<ul>
							<li>queries</li>
							<li>indexes</li>
						</ul>
						<aside class="notes">
						Some field rename operations require special consideration.
						</aside>
					</section>

					<section>
						<h2>Mitigation</h2>
						<ul>
							<li>support both fields</li>
							<li>maintain dual indexes</li>
							<li>backfill migration</li>
						</ul>
					</section>

					<section>
						<h2>Other considerations</h2>
						<ul>
							<li>single-document design</li>
							<li>forward-compatibility</li>
							<li>reversible operations</li>
						</ul>
						<aside class="notes">Other things to consider, we've only employed this technique in a single-document design. I imagine an implementation that considers multiple documents may be possible, but it isn't obvious to me that the abstraction could apply. Also, it's important to be aware that there must be forward compatibility: every deployed consumer must have the latest migrations to support documents saved in the highest schema number. Finally, the changes to the schema must be somehow reversible.</aside>
					</section>

					<section>
						<h2>Implementation (4)</h2>
						<pre><code>@Manager.register
def v10_to_11(manager, case):
    """
    Remove legacy attributes.
    """
    case.pop('survey_name', None)
    case.pop('survey_version', None)
    case.pop('ident', None)</code></pre>
					</section>

				</section>

				<section>
					<aside class="notes">
					 Having dived deep into the code, I'd like to step back out and look at the big picture and showcase the global cluster architecture. (consider "transparent partitioning" as a clarifying synonym for sharding). Go into detail about the advantages and challenges of this approach (shard key selection, ensuring targeted queries even during partition, which is likely across continents).
					</aside>

					<section>
						<h2>Sharding Strategy</h2>
					</section>

					<section>
						<h2>Interview Data Model</h2>
						<img data-src="interview data model 5.png">
					</section>

					<section>
						<h2>Interview Life Cycle</h2>
						<aside class="notes">
						<!-- There are 2 natural phases of the interview life cycle. -->
						<ul>
							<li>collection phase
								<ul>
									<li>relatively short</li>
									<li>very active reads/writes</li>
									<li>most queries target a single document</li>
								</ul>
							</li>
							<li>retention phase
								<ul>
									<li>indefinitely long</li>
									<li>sporadic reads</li>
									<li>neglible writes</li>
									<li>most queries target groups of documents</li>
								</ul>
							</li>
						</ul>
						</aside>
						<img data-src="interview life cycle 7.png">
					</section>

					<section>
						<h2>Interview Data Schema</h2>
						<pre><code>{
	region: "EMEA",
	survey_id: "rfc1274",
	user_id: 216074,
	responses: {
		favourite_drink: "chocolate milk",
		// ...
	}
}</code></pre>

					</section>

					<section>
						<h2>Shard Key Selection</h2>
						<aside class="notes">
						<ul>
							<li>{region: 1, user_id: 1}</li>
							<li>{region: 1, survey_id: 1}</li>
						</ul>
						</aside>
						<img data-src="shard_key_survey_id.png">
					</section>

					<section>
						<h2>Two Datacenters</h2>
						<ul>
							<li>London (a.k.a. "EMEA")</li>
							<li>Palo Alto, CA (a.k.a. "US")</li>
						</ul>
						<img class="auto" data-src="5400_miles.png">
					</section>

					<section>
						<h2>Deploying Shards</h2>
						<img class="auto" data-src="shard makeup 5.png">
						<aside class="notes">
                         Each shard consists of a replica set with (typically) three data-bearing mongod instances (one primary plus two secondaries).
						</aside>
					</section>

					<section>
						<h2>Global Sharded Cluster</h2>
						<img class="auto" data-src="global cluster.png">
						<aside class="notes">
						<ul>
							<li>6 shards
								<ul>
									<li>3 in EMEA</li>
									<li>2 in US</li>
									<li>1 with RS members in both DCs ("EARTH1")</li>
								</ul>
							</li>
						</ul>
						</aside>
					</section>

					<section>
						<h2>Tag-Aware Sharding (1)</h2>
						<pre><code class="javascript" data-trim>
// connect to mongos

// switch to admin database
use admin

// Step 1: Add shards
db.runCommand({addShard: "ldn-rs1/ldn-host1", name: "LDN1"});
db.runCommand({addShard: "ldn-rs2/ldn-host4", name: "LDN2"});
db.runCommand({addShard: "ldn-rs3/ldn-host7", name: "LDN3"});
db.runCommand({addShard: "pa-rs1/pa-host1", name: "PA1"});
db.runCommand({addShard: "pa-rs2/pa-host4", name: "PA2"});
						</code></pre>
					</section>
					<section>
						<h2>Tag-Aware Sharding (2)</h2>
						<pre><code class="javascript" data-trim>
// Step 2: Add shard tags
sh.addShardTag("LDN1", "EMEA");
sh.addShardTag("LDN2", "EMEA");
sh.addShardTag("LDN3", "EMEA");
sh.addShardTag("PA1", "US");
sh.addShardTag("PA2", "US");
						</code></pre>
					</section>
					<section>
						<h2>Tag-Aware Sharding (3)</h2>
						<pre><code class=javascript" data-trim>
// Step 3: Enable sharding
sh.enableSharding("yougov");
sh.shardCollection(
  "yougov.interviews",                     // collection namespace
  {"region": 1, "survey_id": 1}            // shard key pattern
);
						</code></pre>
					</section>
					<section>
						<h2>Tag-Aware Sharding (4)</h2>
						<pre><code class=javascript" data-trim>
// Step 4: Tag each shard key range
sh.addTagRange(
  "yougov.interviews",                     // collection namespace
  {"region": "EMEA", "survey_id": MinKey}, // min value
  {"region": "EMEA", "survey_id": MaxKey}, // max value
  "EMEA"                                   // tag
);
sh.addTagRange(
  "yougov.interviews",                     // collection namespace
  {"region": "US", "survey_id": MinKey},   // min value
  {"region": "US", "survey_id": MaxKey},   // max value
  "US"                                     // tag
);
						</code></pre>
					</section>

					<section>
						<h2>Caution: Non-Targeted Queries</h2>
					</section>

					<section>
						<h2>(Mongo) Database-as-a-Service</h2>
						<ul>
							<li><em>mongos</em> instance running on each app server</li>
							<li>applications connect to mongodb://localhost/</li>
						</ul>
					</section>

					<section>
						<h2>Read Preference "nearest"</h2>
						<ul>
							<li>provides low-latency reads when using geographically distributed replica sets</li>
						</ul>
						<!-- read preference defaults to ReadPreference.PRIMARY -->
						<pre><code>from pymongo import MongoClient, ReadPreference

# set read preference on the client
mongo = MongoClient('localhost',
                    read_preference=ReadPreference.NEAREST)

# ...or on an individual database
mongo = MongoClient('localhost')
db = mongo.get_database('dragoman',
                        read_preference=ReadPreference.NEAREST)</code></pre>
					</section>

					<section>
						<h2>Database Creation</h2>
						<pre><code>def create_db_in_shard(db_name, shard, client=None):
	"""
	In a sharded cluster, create a database in a particular shard.
	"""
	client = client or pymongo.MongoClient()
	# flush the router config to ensure it's not stale
	res = client.admin.command('flushRouterConfig')
	if not res.get('ok'):
		raise RuntimeError("unable to flush router config")
	if shard not in get_ids(client.config.shards):
		raise ValueError(nf("Unknown shard {shard}"))
	if db_name in get_ids(client.config.databases):
		raise ValueError("database already exists")
	# MongoDB doesn't have a 'create database' command, so insert an
	#  item into a collection and then drop the collection.
	client[db_name].foo.insert({'foo': 1})
	client[db_name].foo.drop()
	if client[db_name].collection_names():
		raise ValueError("database has collections")
	res = client.admin.command('movePrimary', value=db_name, to=shard)
	if not res.get('ok'):
		raise RuntimeError(str(res))
	return nf("Successfully created {db_name} in {shard} via {hostname}")</code></pre>
					</section>

					<section>
						<h2>Multi-Dimensional Partitioning</h2>
						<ul>
							<li>still partition for archival</li>
							<li>managed programmatically</li>
							<li>seek additional layers of partitioning</li>
						</ul>
					</section>

					<section>
						<h2>Partitioning Motives</h2>
						<ul>
							<li>locality</li>
							<li>distribution (size)</li>
							<li>distribution (performance)</li>
							<li>storage </li>
						</ul>
					</section>

				</section>

				<section>
					<section>
						<h2>Predictions</h2>
						<ul>
							<li>migrate with whimsy</li>
							<li>all apps in global cluster</li>
						</ul>
						<aside class="notes">YouGov is dedicated to facilitating prediction, and I'll make some predictions of my own based on what I've shared here - with MongoDB, we will continue to migrate our schemas with whimsy and we will support the breadth and depth of our semi-structured data needs in a uniformally managed but geographically diverse global cluster.</aside>
					</section>

					<section>
						<h2>Wishes</h2>
						<ul>
							<li>Supply shard hint, independent from query <a href="https://jira.mongodb.org/browse/SERVER-11991">SERVER-11991</a></li>
							<li>Generalized custom shard logic, independent from data in records</li>
							<li>Oplog-only replica for creating new replicas <a href="https://jira.mongodb.org/browse/SERVER-14539">Server-14539</a></li>
							<li>Embedded solution (sqlite)</li>
						</ul>

						<aside class="notes">While MongoDB has been a fantastic solution for us, allowing us to take for granted that some issues are just solved in the database, we can always imagine improvements. These items are things that I would most like to see in MongoDB.</aside>
					</section>
				</section>

				<section>
					<section>
						<h2>Conclusions</h2>
						<ul>
							<li>If you have dynamically changing data, choose a schemaless database. Take advantage of the schemaless aspects and migrate with whimsy.</li>
							<li>When your company is successful and international, use tag-aware sharding to achieve partitioning of your data without losing control, but let MongoDB manage the abstraction.</li>
						</ul>
					</section>
				</section>

				<section>
					<h1>Questions?</h1>
				</section>

			</div>

		</div>

		<script src="https://yougov.github.io/reveal.js/lib/js/head.min.js"></script>
		<script src="https://yougov.github.io/reveal.js/js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				center: true,

				showNotes: true,

				transition: 'slide', // none/fade/slide/convex/concave/zoom

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'https://yougov.github.io/reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'https://yougov.github.io/reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'https://yougov.github.io/reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'https://yougov.github.io/reveal.js/plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'https://yougov.github.io/reveal.js/plugin/zoom-js/zoom.js', async: true },
					{ src: 'https://yougov.github.io/reveal.js/plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>

</html>
